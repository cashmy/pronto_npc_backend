from rest_framework import serializers
from .models import Image
from django.contrib.auth import get_user_model
from django.utils.translation import gettext_lazy as _

import base64
import uuid
from django.core.files.base import ContentFile


User = get_user_model()

class Base64ImageField(serializers.ImageField):
    """
    A Django REST Framework field for handling image-uploads,
    allowing image data to be passed as a base64-encoded string.
    e.g., "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA..."
    """
    def to_internal_value(self, data):
        if isinstance(data, str) and data.startswith('data:image'):
            try:
                header, base64_str = data.split(';base64,')
                content_type = header.split(':')[-1]
                extension = content_type.split('/')[-1]
                if not extension:
                    raise ValueError("Could not determine file extension from base64 header.")
                decoded_file = base64.b64decode(base64_str)
            except (ValueError, TypeError, base64.binascii.Error) as e:
                raise serializers.ValidationError(_(f"Invalid base64-encoded image: {e}"))

            file_name = f"{uuid.uuid4()}.{extension}"
            content_file = ContentFile(decoded_file, name=file_name)
            
            # Attach extracted metadata to the ContentFile for the serializer to use
            content_file.extracted_mime_type = content_type
            content_file.extracted_file_name = file_name # Same as content_file.name, but explicit
            
            return super().to_internal_value(content_file)
        
        try:
            return super().to_internal_value(data)
        except serializers.ValidationError as e:
            if 'invalid' in e.codes and isinstance(data, str): # Check if it's the "not a file" error for a string
                raise serializers.ValidationError(_("The image must be a file upload or a valid base64-encoded string (e.g., 'data:image/jpeg;base64,...')."))
            raise e

class OwnerSummarySerializer(serializers.ModelSerializer):
    class Meta:
        model = get_user_model()
        fields = ("id", "first_name", "last_name")


class ImageSerializer(serializers.ModelSerializer):
    # Display owner's username (read-only) instead of the full user object or ID
    owner_username = serializers.CharField(
        source="owner.username", read_only=True, allow_null=True
    )
    # Use Base64ImageField for image and thumbnail
    image = Base64ImageField(use_url=True, max_length=None, allow_empty_file=False)
    thumbnail = Base64ImageField(
        use_url=True, required=False, allow_null=True
    )  # Mark as not required
    
    # Metadata fields - allow them to be set, or derive them.
    file_name = serializers.CharField(max_length=255, required=False)
    mime_type = serializers.CharField(max_length=25, required=False)
    file_size = serializers.IntegerField(required=False)

    # Flag to indicate if the owner should be the current user
    use_current_user = serializers.BooleanField(
        write_only=True, required=False, default=False
    )

    owner = OwnerSummarySerializer(read_only=True)

    class Meta:
        model = Image
        fields = [
            "id",
            "file_name", # Now handled by field declaration and validate method
            "alt_text",
            "mime_type", # Now handled by field declaration and validate method
            "file_size", # Now handled by field declaration and validate method
            "image",
            "thumbnail",
            "image_type",
            "owner_username",  # Use username instead of user/user_id
            "owner",  # Owner serializer for detailed info (read-only)
            "use_current_user",  # Include the flag for input
            "created_at",
            "updated_at",
        ]
        # Fields that are set automatically or shouldn't be directly input
        read_only_fields = [
            "id",  # Auto-generated by the database
            "owner_username",
            "owner",  # Owner is set automatically
            "created_at",
            "updated_at",
            "owner",
        ]
        # Avoid depth = 1, use explicit fields like owner_username

    def validate(self, attrs):
        attrs = super().validate(attrs) # Basic field validation
        image_file = attrs.get("image") # This is a ContentFile or UploadedFile

        # If a new image is being uploaded (either form-data or base64)
        if image_file:
            # Populate file_name if not explicitly provided by the user in the request
            if not attrs.get("file_name"):
                attrs["file_name"] = getattr(image_file, 'extracted_file_name', image_file.name)

            # Always (re)calculate file_size from the actual file data
            attrs["file_size"] = image_file.size

            # Always (re)determine mime_type from the actual file data or base64 header
            if hasattr(image_file, 'extracted_mime_type'):
                attrs["mime_type"] = image_file.extracted_mime_type
            elif hasattr(image_file, 'content_type'): # For regular Django UploadedFile
                attrs["mime_type"] = image_file.content_type
            elif not attrs.get("mime_type"): # If user didn't provide and we can't derive
                raise serializers.ValidationError({
                    "mime_type": _("Mime type could not be determined for the uploaded image and was not provided.")
                })
        # On create, if no image is provided, model field validation for 'image' should catch it.
        # If 'image' is not nullable on model, this 'if image_file:' block will always execute on create.

        # Note: If 'thumbnail' also needs its own metadata fields on the model,
        # similar logic would apply here for 'thumbnail_file'.
        # Currently, file_name, mime_type, file_size seem to be for the main 'image'.

        return attrs

    # Correctly indented create method
    def create(self, validated_data):
        """
        Set the owner to the logged-in user from the request context if flag is set.
        File metadata (file_name, file_size, mime_type) should already be in
        validated_data thanks to the `validate` method if an image was provided.
        """
        owner_instance = None

        # Pop the flag before creating the model instance
        use_current_user_flag = validated_data.pop("use_current_user", False)

        request = self.context.get("request")
        # image_file = validated_data.get("image")

        # Set owner based on the flag
        if use_current_user_flag:
            if request and hasattr(request, "user") and request.user.is_authenticated:
                owner_instance = request.user
            # else: owner remains None (global image) if flag is true but user not logged in

        # Handle potential thumbnail generation here if desired

        # Create the instance, passing owner explicitly
        instance = Image.objects.create(owner=owner_instance, **validated_data)
        return instance

    def update(self, instance, validated_data):
        """
        File metadata (file_name, file_size, mime_type) will be updated by the
        `validate` method if a new image is part of `validated_data`.
        """
        # Pop the flag if it was somehow included in PATCH/PUT data
        validated_data.pop("use_current_user", None)
        # Prevent owner from being changed during update
        validated_data.pop("owner", None)
        # Other fields, including image and its metadata, will be updated by super().update()

        return super().update(instance, validated_data)


# Serializer for the dropdown options in the frontend
class ImageOptionSerializer(serializers.ModelSerializer):
    image_url = serializers.ImageField(source="image")
    thumbnail_url = serializers.ImageField(source="thumbnail", allow_null=True)

    class Meta:
        model = Image
        fields = [
            "id",
            "file_name",
            "alt_text",  # Correctly included now
            "image_url",  # Will now be a URL
            "thumbnail_url",  # Will now be a URL (optional)
            "image_type",
            "mime_type",
            "file_size",
            "owner",  # Owner serializer for detailed info (read-only)
        ]
